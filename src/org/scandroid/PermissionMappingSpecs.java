/**
 * 
 */
package org.scandroid;

import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.UTFDataFormatException;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.scandroid.spec.CallArgSinkSpec;
import org.scandroid.spec.CallArgSourceSpec;
import org.scandroid.spec.CallRetSourceSpec;
import org.scandroid.spec.ISpecs;
import org.scandroid.spec.MethodNamePattern;
import org.scandroid.spec.SinkSpec;
import org.scandroid.spec.SourceSpec;

import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.ibm.wala.types.MethodReference;
import com.ibm.wala.util.strings.StringStuff;

/**
 * An ISpecs implementation generated from the PScout permission mappings. The
 * inputstream these constructors expect is *not* the raw PScout file, but
 * rather a parsed version of that file that has been serialized as a
 * java.util.Map from permission names to sets of method signatures.
 * 
 * @author acfoltzer
 * 
 */
public class PermissionMappingSpecs implements ISpecs {
	private final Map<String, Set<String>> mappings;
	private final SourceSpec[] sources;
	private final SinkSpec[] sinks;

	/**
	 * Generate sources and sinks for all permissions in the given mappings
	 * 
	 * @param mappings
	 *            file generated by pscoutParser
	 * @throws IOException
	 * @throws ClassNotFoundException
	 */
	@SuppressWarnings("unchecked")
	public PermissionMappingSpecs(InputStream mappingStream)
			throws ClassNotFoundException, IOException {
		this.mappings = (Map<String, Set<String>>) new ObjectInputStream(
				mappingStream).readObject();
		Set<SourceSpec> sourceSet = Sets.newHashSet();
		Set<SinkSpec> sinkSet = Sets.newHashSet();
		for (Entry<String, Set<String>> entry : mappings.entrySet()) {
			sourceSet.addAll(sourcesForSet(entry.getValue()));
			sinkSet.addAll(sinksForSet(entry.getValue()));
		}
		this.sources = (SourceSpec[]) sourceSet.toArray(new SourceSpec[sourceSet.size()]);
		this.sinks = (SinkSpec[]) sinkSet.toArray(new SinkSpec[sinkSet.size()]);
	}

	/**
	 * Generate sources and sinks only for those permissions specified.
	 * 
	 * @param mappingStream
	 *            file generated by pscoutParser
	 * @param sourcePermissions
	 *            for which to make sources
	 * @param sinkPermissions
	 *            for which to make sinks
	 * @throws IOException
	 * @throws ClassNotFoundException
	 */
	public PermissionMappingSpecs(InputStream mappingStream,
			Set<String> sourcePermissions, Set<String> sinkPermissions)
			throws ClassNotFoundException, IOException {
		this.mappings = (Map<String, Set<String>>) new ObjectInputStream(
				mappingStream).readObject();
		Set<SourceSpec> sourceSet = Sets.newHashSet();
		Set<SinkSpec> sinkSet = Sets.newHashSet();

		for (String sourcePermission : sourcePermissions) {
			sourceSet.addAll(sourcesForSet(mappings.get(sourcePermission)));
		}

		for (String sinkPermission : sinkPermissions) {
			sinkSet.addAll(sinksForSet(mappings.get(sinkPermission)));
		}

		this.sources = (SourceSpec[]) sourceSet.toArray();
		this.sinks = (SinkSpec[]) sinkSet.toArray();
	}

	private List<SourceSpec> sourcesForSet(Set<String> set)
			throws UTFDataFormatException {
		List<SourceSpec> result = Lists.newLinkedList();
		for (String methodString : set) {
			MethodReference methodRef = StringStuff
					.makeMethodReference(methodString);
			MethodNamePattern pattern = MethodNamePattern
					.patternForReference(methodRef);

			// the pscout results don't record static vs. non-static, so we
			// assume it could be either

			int[] staticArgs = new int[methodRef.getNumberOfParameters()];
			for (int i = 0; i < staticArgs.length; i++) {
				staticArgs[i] = i;
			}
			int[] virtualArgs = new int[methodRef.getNumberOfParameters() + 1];
			for (int i = 0; i < virtualArgs.length; i++) {
				virtualArgs[i] = i;
			}

			result.add(new CallArgSourceSpec(pattern, staticArgs));
			result.add(new CallArgSourceSpec(pattern, virtualArgs));
			result.add(new CallRetSourceSpec(pattern, new int[] {}));
		}
		return result;
	}

	private List<SinkSpec> sinksForSet(Set<String> set)
			throws UTFDataFormatException {
		List<SinkSpec> result = Lists.newLinkedList();
		for (String methodString : set) {
			MethodReference methodRef = StringStuff
					.makeMethodReference(methodString);
			MethodNamePattern pattern = MethodNamePattern
					.patternForReference(methodRef);

			// the pscout results don't record static vs. non-static, so we
			// assume it could be either

			int[] staticArgs = new int[methodRef.getNumberOfParameters()];
			for (int i = 0; i < staticArgs.length; i++) {
				staticArgs[i] = i;
			}
			int[] virtualArgs = new int[methodRef.getNumberOfParameters() + 1];
			for (int i = 0; i < virtualArgs.length; i++) {
				virtualArgs[i] = i;
			}

			result.add(new CallArgSinkSpec(pattern, staticArgs));
			result.add(new CallArgSinkSpec(pattern, virtualArgs));
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.scandroid.spec.ISpecs#getEntrypointSpecs()
	 */
	@Override
	public MethodNamePattern[] getEntrypointSpecs() {
		return new MethodNamePattern[] {};
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.scandroid.spec.ISpecs#getSourceSpecs()
	 */
	@Override
	public SourceSpec[] getSourceSpecs() {
		return sources;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.scandroid.spec.ISpecs#getSinkSpecs()
	 */
	@Override
	public SinkSpec[] getSinkSpecs() {
		return sinks;
	}

}
